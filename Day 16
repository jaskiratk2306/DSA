Q1. Merge Two Sorted Lists (Leetcode - 21)

class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        
        if(list1 == nullptr){
            return list2;
        }

        if(list2 == nullptr){
            return list1;
        }

        if(list1->val <= list2 ->val){
            list1->next = mergeTwoLists(list1->next,list2);
            return list1;
        }

        else{
            list2->next = mergeTwoLists(list1,list2->next);
            return list2;
        }


    }
};

Q2.Intersection of two linked lists (Leetcode - 160)

lass Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        int n1=0;
        int n2=0;
        ListNode* curr1=headA;
        ListNode* curr2=headB;

        while(curr1){
            n1++;
            curr1=curr1->next;
        }

        while(curr2){
            n2++;
            curr2=curr2->next;
        }

        int k = abs(n1-n2);
        if(n1>n2){
            curr1=headA;
            curr2=headB;
        }
        else{
            curr1=headB;
            curr2=headA;
        }
        
        for(int i=0;i<k;i++) curr1=curr1->next;
        while(curr1!=nullptr and curr2 != nullptr){
            if(curr1 == curr2) return curr1;
            curr1=curr1->next;
            curr2=curr2->next;
        }
        return nullptr;

    }
};

Q3.Remove Nth Node From End of list (Leetcode - 19)

class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        
        int size=0;
        ListNode* curr = head;
        
        while(curr){
            size++;
            curr=curr->next;
        }
        
        if(n==size) return head->next;

        curr=head;
        for(int i=1; i < size-n ;i++){
            curr=curr->next;
        }  

        curr->next = curr->next->next;  
        return head;
    }
};

Q4.Longest Balance Subarray I (Leetcode - 3719)

class Solution {
public:
    int longestBalanced(vector<int>& nums) {
        int ans = 0;
        int n = nums.size();
        for (int i = 0; i < n; i++) {
            unordered_set<int> even, odd;
            for (int j = i; j < n; j++) {
                if (nums[j] % 2 == 0) even.insert(nums[j]);
                else odd.insert(nums[j]);
                
                if (even.size() == odd.size()) {
                    ans = max(ans, j - i + 1);
                }
            }
        }
        return ans;
    }
};


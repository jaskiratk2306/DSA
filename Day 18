Q1.Longest Balanced Substring || (Leetcode - 3714)

class Solution {
public:
    int longestBalanced(string s) {
        int n = (int)s.size();
        int ans = 0;

        for (int i = 0; i < n; ) {
            int start = i;
            i++;
            while (i < n && s[i] == s[i - 1]) i++;
            ans = max(ans, i - start);
        }

        auto twoChars = [&](char x, char y) {
            int i = 0;
            vector<int> first(2 * n + 1, INT_MAX);
            vector<int> touched;
            touched.reserve(2 * n + 1);

            while (i < n) {
                int segStart = i;
                first[n] = segStart - 1;
                touched.push_back(n);

                int d = 0;
                while (i < n && (s[i] == x || s[i] == y)) {
                    d += (s[i] == x) ? 1 : -1;
                    int idx = d + n;
                    if (first[idx] != INT_MAX) {
                        ans = max(ans, i - first[idx]);
                    } else {
                        first[idx] = i;
                        touched.push_back(idx);
                    }
                    i++;
                }

                for (int idx : touched) 
                    first[idx] = INT_MAX;
                touched.clear();

                i++; 
            }
        };

        twoChars('a','b');
        twoChars('a','c');
        twoChars('b','c');

        unordered_map<long long, int> pos;
        pos.reserve(n * 2 + 1);

        auto key = [&](int d1, int d2) -> long long {
            return ( (long long)d1 << 32 ) ^ (unsigned int)d2;
        };

        int ca = 0, cb = 0, cc = 0;
        pos[key(0,0)] = -1;

        for (int i = 0; i < n; i++) {
            if (s[i] == 'a') 
                ca++;
            else if (s[i] == 'b') 
                cb++;
            else if (s[i] == 'c') 
                cc++;

            int d1 = ca - cb;
            int d2 = cb - cc;
            long long k = key(d1, d2);

            auto it = pos.find(k);
            if (it != pos.end()) 
                ans = max(ans, i - it->second);
            else pos[k] = i;
        }

        return ans;
    }
};

Q2.Champagne Tower (Leetcode - 799)

class Solution {
public:
    double champagneTower(int poured, int query_row, int query_glass) {
        double tower[102][102] = {0.0};
        tower[0][0] = (double)poured;
        
        for (int r = 0; r <= query_row; r++) {
            for (int c = 0; c <= r; c++) {
                if (tower[r][c] > 1.0) {
                    double excess = (tower[r][c] - 1.0) / 2.0;
                    tower[r][c] = 1.0;
                    tower[r + 1][c] += excess;
                    tower[r + 1][c + 1] += excess;
                }
            }
        }
        return tower[query_row][query_glass];
    }
};

Q3.Add Binary (Leetcode - 67)

class Solution {
public:
    string addBinary(string a, string b) {
        string ans;
        int carry = 0;
        int i = a.length() - 1;
        int j = b.length() - 1;

        while(i>=0 || j>=0 || carry){
            if(i>=0){
                carry += a[i--] - '0';
            }
            if(j >= 0){
                carry += b[j--] - '0';
            }
            ans += carry%2 + '0';
            carry /= 2;
        }

        reverse(begin(ans),end(ans));
        return ans;
        
    }
};
